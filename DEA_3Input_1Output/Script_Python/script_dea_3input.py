# -*- coding: utf-8 -*-
"""Script_DEA_3Input.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_pqR8TmQX96nbOvsZvzy_m2vI2aCnW_E

Link github repo: https://github.com/NibuTake/PyDEA

Link documentazione: https://nibutake.github.io/PyDEA/index.html
"""

!pip install Pyfrontier

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
import numpy as np

from Pyfrontier.frontier_model import EnvelopDEA

from google.colab import files
uploaded = files.upload()

# Caricamento dateset in csv
df = pd.read_csv('Dataset.csv')

# Impostazione della colonna 'dmu' come indice
df.set_index('dmu', inplace=True)

df

# Applicazione modello DEA: CCR, input-oriented
dea = EnvelopDEA("CRS", "in")

# Esecuzione del fit con il dataset
dea.fit(
    df[["i_deviazionestandard", "i_beta", "i_commissionedingresso"]].to_numpy(),
    df[["o_rendimentoatteso"]].to_numpy()
)

# Visualizzazione dati del modello per ogni DMU

# Creazione di una lista di dizionari per ogni DMU
results = []

# Itera su tutti i risultati delle DMU
for i, result in enumerate(dea.result):
    # Salva i risultati di ciascuna DMU in un dizionario
    dmu_result = {
        "Punteggio di efficienza": result.score,  # Punteggio di efficienza
    }
    results.append(dmu_result)

# Creazione del DataFrame a partire dalla lista di dizionari
results_df = pd.DataFrame(results)


# Impostazione dell'indice del DataFrame come i nomi delle DMU (assumendo che i nomi delle DMU siano nell'indice di df)
results_df.index = df.index

# Download dataframe con i dati su ogni DMU
results_df.to_csv("DMU_efficienza.csv", index=True)
files.download("DMU_efficienza.csv")

results_df

# Visualizzazione grafica 3D dell'efficienza delle DMU

# Creazione del grafico 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Estrai i DMU efficienti e inefficienti in base ai punteggi di efficienza
eff_dmu = [r.dmu for r in dea.result if r.score == 1.0]  # Solo DMU con punteggio di efficienza 1
ineff_dmu = [r.dmu for r in dea.result if r.score != 1.0]  # DMU con punteggio di efficienza diverso da 1

# Verifica il numero totale di DMU
total_dmu = len(dea.result)
num_eff_dmu = len(eff_dmu)
num_ineff_dmu = len(ineff_dmu)

# Stampa il numero di DMU
print(f"Numero totale di DMU: {total_dmu}")
print(f"Numero di DMU efficienti: {num_eff_dmu}")
print(f"Numero di DMU inefficienti: {num_ineff_dmu}")

# Estrai i valori per ridimensionare automaticamente gli assi
x_vals = [d.input[0] for d in eff_dmu + ineff_dmu]
y_vals = [d.input[1] for d in eff_dmu + ineff_dmu]
z_vals = [d.input[2] for d in eff_dmu + ineff_dmu]

# Scatter plot per DMU efficienti (blu con bordo nero)
ax.scatter(
    [d.input[0] for d in eff_dmu],
    [d.input[1] for d in eff_dmu],
    [d.input[2] for d in eff_dmu],
    color="red", label="DMU efficienti", marker="o", s=150, edgecolors="black", linewidths=2
)

# Scatter plot per DMU inefficienti (rosso con bordo nero)
ax.scatter(
    [d.input[0] for d in ineff_dmu],
    [d.input[1] for d in ineff_dmu],
    [d.input[2] for d in ineff_dmu],
    color="blue", label="DMU non efficienti", marker="o", s=150, edgecolors="black", linewidths=2
)

# Auto-scaling per evitare tagli
x1=ax.set_xlim([min(x_vals) - np.ptp(x_vals) * 0.1, max(x_vals) + np.ptp(x_vals) * 0.1])
x2=ax.set_ylim([min(y_vals) - np.ptp(y_vals) * 0.1, max(y_vals) + np.ptp(y_vals) * 0.1])
x3=ax.set_zlim([min(z_vals) - np.ptp(z_vals) * 0.1, max(z_vals) + np.ptp(z_vals) * 0.1])

# Imposta sfondo trasparente
fig.patch.set_alpha(0)  # Sfondo trasparente per tutta la figura
ax.set_facecolor((0, 0, 0, 0))  # Sfondo trasparente per gli assi

# Imposta la vista 3D per una migliore leggibilità
ax.view_init(elev=20, azim=135)  # Modifica questi valori se vuoi una prospettiva diversa

# Miglioramenti estetici
ax.legend(fontsize=12)
ax.grid(True)  # Aggiunge una griglia leggera per aiutare la lettura

# Salva l'immagine con sfondo trasparente
plt.savefig("grafico_trasparente.png", dpi=300, bbox_inches="tight", transparent=True)

# Mostra il grafico
plt.show()

# Calcolo delle combinazioni efficienti per ogni DMU

# Creazione di un dataframe vuoto per le combinazioni efficienti
df_dmu_comb_eff = pd.DataFrame(columns=[f"{df.index[i]}" for i in range(len(dea.result))])

# Iterazione su tutti i risultati delle DMU
for i, result in enumerate(dea.result):
    # Estrarre i pesi lambda
    lambda_weights = result.weights

    # Crea un dizionario per memorizzare i pesi di ciascuna DMU
    dmu_weights = {f"{j}": (lambda_weights[j] if lambda_weights[j] > 0 else 0) for j in range(len(lambda_weights))}

    # Aggiungi i pesi nel dataframe
    df_dmu_comb_eff.loc[i] = list(dmu_weights.values())

# Impostazione i nomi delle DMU come indice del dataframe
df_dmu_comb_eff.index = df.index

df_dmu_comb_eff

# Calcolo della composizione normalizzata per ogni DMU, a parità di input inziale

# Normalizzazione delle righe: ogni valore diviso per la somma della riga
df_normalized_comb_eff = df_dmu_comb_eff.div(df_dmu_comb_eff.sum(axis=1), axis=0)

df_normalized_comb_eff.index = df.index

# Download dataframe con combinazioni efficienti per ogni DMU
df_normalized_comb_eff.to_csv("DMU_combinazioni_efficienti_pesi.csv", index=True)
files.download("DMU_combinazioni_efficienti_pesi.csv")

df_normalized_comb_eff

# Creazione dataframe con input e output ponderati per le combinazioni efficienti di ogni DMU

# Creazione di una lista per memorizzare i nuovi input e output ponderati
inputs_dmu_efficienti = []
outputs_dmu_efficienti = []

# Iterazione su ogni DMU (ogni riga di df_normalized_comb_eff)
for i, row in df_normalized_comb_eff.iterrows():
    # Calcolo della somma ponderata degli input (ora includendo il terzo input)
    weighted_inputs = row.dot(df[["i_deviazionestandard", "i_beta", "i_commissionedingresso"]].to_numpy())
    # Calcolo della somma ponderata degli output
    weighted_outputs = row.dot(df[["o_rendimentoatteso"]].to_numpy())[0]

    # Aggiungi i nuovi input e output al dataframe finale
    inputs_dmu_efficienti.append(weighted_inputs)
    outputs_dmu_efficienti.append(weighted_outputs)

# Creazione di un dataframe con i nuovi input e output ponderati
df_dmu_efficienti = pd.DataFrame({
    "Deviazione standard ponderato": [x[0] for x in inputs_dmu_efficienti],
    "Beta ponderato": [x[1] for x in inputs_dmu_efficienti],
    "Commissione d'ingresso ponderato": [x[2] for x in inputs_dmu_efficienti],  # Aggiungi il terzo input
    "Rendimento atteso ponderato": outputs_dmu_efficienti
})

df_dmu_efficienti.index = df.index

# Download dataframe con i dati per ogni DMU virtuale
df_dmu_efficienti.to_csv("DMU_efficienti_input_output.csv", index=True)
files.download("DMU_efficienti_input_output.csv")

# Visualizza il dataframe finale
df_dmu_efficienti

# Creazione di una lista dei punti per i DMU efficienti (dal dataframe originale)
eff_dmu_inputs = df[["i_deviazionestandard", "i_beta", "i_commissionedingresso"]].iloc[
    [i for i, r in enumerate(dea.result) if r.score == 1]].to_numpy()  # Selezione in base al punteggio effettivo
eff_dmu_outputs = df[["o_rendimentoatteso"]].iloc[
    [i for i, r in enumerate(dea.result) if r.score == 1]].to_numpy()

# Aggiunta dei punti delle combinazioni ponderate (dal dataframe df_new)
comb_eff_inputs = df_dmu_efficienti[["Deviazione standard ponderato", "Beta ponderato", "Commissione d'ingresso ponderato"]].to_numpy()
comb_eff_outputs = df_dmu_efficienti["Rendimento atteso ponderato"].to_numpy()

# Contare il numero di DMU efficienti e inefficienti
num_eff_dmu = sum(1 for r in dea.result if r.score == 1)  # Efficienti per punteggio
num_ineff_dmu = sum(1 for r in dea.result if r.score < 1)  # Inefficienti per punteggio

# Verifica che il numero totale di DMU sia corretto (52)
total_dmu = len(dea.result)

print(f"Numero totale di DMU: {total_dmu}")
print(f"Numero di DMU efficienti: {num_eff_dmu}")
print(f"Numero di DMU inefficienti: {num_ineff_dmu}")

# Creazione del grafico 3D
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection="3d")

# Visualizzazione DMU efficienti (in rosso) e le nuove combinazioni di DMU efficienti (in blu)
ax.scatter(
    eff_dmu_inputs[:, 0], eff_dmu_inputs[:, 1], eff_dmu_inputs[:, 2],
    color="red", label="DMU efficienti", marker="o", s=150, edgecolors="black", linewidths=2
)
ax.scatter(
    comb_eff_inputs[:, 0], comb_eff_inputs[:, 1], comb_eff_inputs[:, 2],
    color="blue", label="Combinazioni efficienti", marker="x", s=150, linewidths=2  # Rimosso `edgecolors`
)

# Etichette degli assi
#ax.set_xlabel("Deviazione standard", fontsize=14, labelpad=12)
#ax.set_ylabel("Beta", fontsize=14, labelpad=12)
#ax.set_zlabel("Commissione d'ingresso", fontsize=14, labelpad=12)
#ax.set_title("Frontiera Efficiente con Combinazioni di DMU", fontsize=16)

# Estrai i valori per ridimensionare automaticamente gli assi
x_vals = np.concatenate((eff_dmu_inputs[:, 0], comb_eff_inputs[:, 0]))
y_vals = np.concatenate((eff_dmu_inputs[:, 1], comb_eff_inputs[:, 1]))
z_vals = np.concatenate((eff_dmu_inputs[:, 2], comb_eff_inputs[:, 2]))

# Auto-scaling per evitare tagli
ax.set_xlim(x1)
ax.set_ylim(x2)
ax.set_zlim(x3)

# Imposta sfondo trasparente
fig.patch.set_alpha(0)  # Sfondo trasparente per tutta la figura
ax.set_facecolor((0, 0, 0, 0))  # Sfondo trasparente per gli assi

# Imposta la vista 3D per una migliore leggibilità
ax.view_init(elev=20, azim=135)  # Modifica questi valori se vuoi una prospettiva diversa

# Miglioramenti estetici
ax.legend(fontsize=12)
ax.grid(True)  # Aggiunge una griglia leggera per aiutare la lettura

# Salva l'immagine con sfondo trasparente
plt.savefig("grafico_trasparente_combinazioni.png", dpi=300, bbox_inches="tight", transparent=True)

# Mostra il grafico
plt.show()